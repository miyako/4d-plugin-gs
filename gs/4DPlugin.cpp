/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : GS
 #	author : miyako
 #	2017/07/22
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Ghostscript

		case 1 :
			GS(pResult, pParams);
			break;

	}
}

// ---------------------------------- Ghostscript ---------------------------------


void GS(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	void *minst;
	
#if VERSIONMAC
	std::vector<CUTF8String>_gsargv;
#else
	std::vector<CUTF16String>_gsargv;
#endif
	
	std::vector<char *>gsargv;
	
	for(unsigned int i = 0;i < Param1.getSize();++i)
	{
#if VERSIONMAC
		CUTF8String _argv;
		Param1.copyUTF8StringAtIndex(&_argv, i);
#else
		CUTF16String _argv;
		Param1.copyUTF16StringAtIndex(&_argv, i);
#endif
		_gsargv.push_back(_argv);
		gsargv.push_back((char *)(_gsargv.at(i).c_str()));
	}
	
	int gsargc = gsargv.size();
	
	if(gsapi_new_instance(&minst, NULL) == 0)
	{
#if VERSIONMAC
		gsapi_set_arg_encoding(minst, GS_ARG_ENCODING_UTF8);
#else
		gsapi_set_arg_encoding(minst, GS_ARG_ENCODING_UTF16LE);
#endif
		
		returnValue.setIntValue(gsapi_init_with_args(minst, gsargc, (char **)&gsargv[0]));

		gsapi_exit(minst);//finalises the output
		gsapi_delete_instance(minst);
	}
	
	returnValue.setReturn(pResult);
}

